"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_client_dist__chunks-es_stegaEncodeSourceMap_js"],{

/***/ "(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_FOLDER = \"drafts\", VERSION_FOLDER = \"versions\", PATH_SEPARATOR = \".\", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;\nfunction isDraftId(id) {\n  return id.startsWith(DRAFTS_PREFIX);\n}\nfunction isVersionId(id) {\n  return id.startsWith(VERSION_PREFIX);\n}\nfunction isPublishedId(id) {\n  return !isDraftId(id) && !isVersionId(id);\n}\nfunction getVersionFromId(id) {\n  if (!isVersionId(id)) return;\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);\n  return versionId;\n}\nfunction getPublishedId(id) {\n  return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), isPublishedId(_id))\n    searchParams.set(\"perspective\", \"published\");\n  else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id);\n    searchParams.set(\"perspective\", versionId);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl) return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsUUFBUTtBQUNsQztBQUNBLGdCQUFnQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUN0RDtBQUNBLGdCQUFnQixPQUFPLFVBQVUsYUFBYTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxLQUFLLEdBQUcsR0FBRztBQUNyQztBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0QsNERBQTRELHVDQUF1QyxRQUFRLDBDQUEwQyx5REFBeUQsV0FBVyxlQUFlLGFBQWE7QUFDMVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBS0M7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxteS1oYWNrYXRob25cXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcY2xpZW50XFxkaXN0XFxfY2h1bmtzLWVzXFxzdGVnYUVuY29kZVNvdXJjZU1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDIH0gZnJvbSBcIi4vc3RlZ2FDbGVhbi5qc1wiO1xuY29uc3QgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vO1xuZnVuY3Rpb24gaXNLZXlTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyByZUtleVNlZ21lbnQudGVzdChzZWdtZW50LnRyaW0oKSkgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuY29uc3QgRVNDQVBFID0ge1xuICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgXCJcXHJcIjogXCJcXFxcclwiLFxuICBcIlx0XCI6IFwiXFxcXHRcIixcbiAgXCInXCI6IFwiXFxcXCdcIixcbiAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxufSwgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBgXG5gLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24ganNvblBhdGgocGF0aCkge1xuICByZXR1cm4gYCQke3BhdGgubWFwKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gYFsnJHtzZWdtZW50LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nXWAgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiID8gYFske3NlZ21lbnR9XWAgOiBzZWdtZW50Ll9rZXkgIT09IFwiXCIgPyBgWz8oQC5fa2V5PT0nJHtzZWdtZW50Ll9rZXkucmVwbGFjZSgvWydcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfScpXWAgOiBgWyR7c2VnbWVudC5faW5kZXh9XWApLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlSnNvblBhdGgocGF0aCkge1xuICBjb25zdCBwYXJzZWQgPSBbXSwgcGFyc2VSZSA9IC9cXFsnKC4qPyknXFxdfFxcWyhcXGQrKVxcXXxcXFtcXD9cXChAXFwuX2tleT09JyguKj8pJ1xcKVxcXS9nO1xuICBsZXQgbWF0Y2g7XG4gIGZvciAoOyAobWF0Y2ggPSBwYXJzZVJlLmV4ZWMocGF0aCkpICE9PSBudWxsOyApIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBfa2V5ID0gbWF0Y2hbM10ucmVwbGFjZSgvXFxcXChcXFxcJykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX2luZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9rZXkgIT09IFwiXCIpXG4gICAgICByZXR1cm4geyBfa2V5OiBzZWdtZW50Ll9rZXkgfTtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCFjc20/Lm1hcHBpbmdzKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9KTtcbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiIHx8IHZhbHVlLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgPyByZXN1bHQuY2hpbGRyZW4gPSB3YWxrTWFwKHZhbHVlLmNoaWxkcmVuLCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwiY2hpbGRyZW5cIikpIDogdmFsdWUuX3R5cGUgPT09IFwic3BhblwiICYmIChyZXN1bHQudGV4dCA9IHdhbGtNYXAodmFsdWUudGV4dCwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcInRleHRcIikpKSwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfRk9MREVSID0gXCJkcmFmdHNcIiwgVkVSU0lPTl9GT0xERVIgPSBcInZlcnNpb25zXCIsIFBBVEhfU0VQQVJBVE9SID0gXCIuXCIsIERSQUZUU19QUkVGSVggPSBgJHtEUkFGVFNfRk9MREVSfSR7UEFUSF9TRVBBUkFUT1J9YCwgVkVSU0lPTl9QUkVGSVggPSBgJHtWRVJTSU9OX0ZPTERFUn0ke1BBVEhfU0VQQVJBVE9SfWA7XG5mdW5jdGlvbiBpc0RyYWZ0SWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25JZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChWRVJTSU9OX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1B1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiAhaXNEcmFmdElkKGlkKSAmJiAhaXNWZXJzaW9uSWQoaWQpO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbkZyb21JZChpZCkge1xuICBpZiAoIWlzVmVyc2lvbklkKGlkKSkgcmV0dXJuO1xuICBjb25zdCBbX3ZlcnNpb25QcmVmaXgsIHZlcnNpb25JZCwgLi4uX3B1Ymxpc2hlZElkXSA9IGlkLnNwbGl0KFBBVEhfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIHZlcnNpb25JZDtcbn1cbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiBpc1ZlcnNpb25JZChpZCkgPyBpZC5zcGxpdChQQVRIX1NFUEFSQVRPUikuc2xpY2UoMikuam9pbihQQVRIX1NFUEFSQVRPUikgOiBpc0RyYWZ0SWQoaWQpID8gaWQuc2xpY2UoRFJBRlRTX1BSRUZJWC5sZW5ndGgpIDogaWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0VXJsKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgd29ya3NwYWNlOiBfd29ya3NwYWNlID0gXCJkZWZhdWx0XCIsXG4gICAgdG9vbDogX3Rvb2wgPSBcImRlZmF1bHRcIixcbiAgICBpZDogX2lkLFxuICAgIHR5cGUsXG4gICAgcGF0aCxcbiAgICBwcm9qZWN0SWQsXG4gICAgZGF0YXNldFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFiYXNlVXJsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghcGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIV9pZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKGJhc2VVcmwgIT09IFwiL1wiICYmIGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgbXVzdCBub3QgZW5kIHdpdGggYSBzbGFzaFwiKTtcbiAgY29uc3Qgd29ya3NwYWNlID0gX3dvcmtzcGFjZSA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfd29ya3NwYWNlLCB0b29sID0gX3Rvb2wgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3Rvb2wsIGlkID0gZ2V0UHVibGlzaGVkSWQoX2lkKSwgc3RyaW5naWZpZWRQYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKSA6IHBhdGgsIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIGJhc2VVcmwsXG4gICAgaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoOiBzdHJpbmdpZmllZFBhdGhcbiAgfSk7XG4gIGlmICh3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpLCBpc1B1Ymxpc2hlZElkKF9pZCkpXG4gICAgc2VhcmNoUGFyYW1zLnNldChcInBlcnNwZWN0aXZlXCIsIFwicHVibGlzaGVkXCIpO1xuICBlbHNlIGlmIChpc1ZlcnNpb25JZChfaWQpKSB7XG4gICAgY29uc3QgdmVyc2lvbklkID0gZ2V0VmVyc2lvbkZyb21JZChfaWQpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwZXJzcGVjdGl2ZVwiLCB2ZXJzaW9uSWQpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIChlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IGVuZFBhdGguZW5kc1dpdGgoXCJJZFwiKSkgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgaGFzVHlwZUxpa2Uoc291cmNlUGF0aCkgfHwgaGFzVHlwZUxpa2UocmVzdWx0UGF0aCkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ0ZXh0VGhlbWVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwsIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhhc1R5cGVMaWtlKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc29tZSgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50Lm1hdGNoKC90eXBlL2kpICE9PSBudWxsKTtcbn1cbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZykge1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgbG9nZ2VyPy5lcnJvcj8uKGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gbG9nZ2VyPy5lcnJvcj8uKFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgdmFsdWUgfSkpID09PSAhMSlcbiAgICAgICAgcmV0dXJuIGxvZ2dlciAmJiByZXBvcnQuc2tpcHBlZC5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgICAgfSksIHZhbHVlO1xuICAgICAgbG9nZ2VyICYmIHJlcG9ydC5lbmNvZGVkLnB1c2goe1xuICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGJhc2VVcmwsIHdvcmtzcGFjZSwgdG9vbCB9ID0gcmVzb2x2ZVN0dWRpb0Jhc2VSb3V0ZShcbiAgICAgICAgdHlwZW9mIGNvbmZpZy5zdHVkaW9VcmwgPT0gXCJmdW5jdGlvblwiID8gY29uZmlnLnN0dWRpb1VybChzb3VyY2VEb2N1bWVudCkgOiBjb25maWcuc3R1ZGlvVXJsXG4gICAgICApO1xuICAgICAgaWYgKCFiYXNlVXJsKSByZXR1cm4gdmFsdWU7XG4gICAgICBjb25zdCB7IF9pZDogaWQsIF90eXBlOiB0eXBlLCBfcHJvamVjdElkOiBwcm9qZWN0SWQsIF9kYXRhc2V0OiBkYXRhc2V0IH0gPSBzb3VyY2VEb2N1bWVudDtcbiAgICAgIHJldHVybiBDKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbjogXCJzYW5pdHkuaW9cIixcbiAgICAgICAgICBocmVmOiBjcmVhdGVFZGl0VXJsKHtcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICB3b3Jrc3BhY2UsXG4gICAgICAgICAgICB0b29sLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogc291cmNlUGF0aCxcbiAgICAgICAgICAgIC4uLiFjb25maWcub21pdENyb3NzRGF0YXNldFJlZmVyZW5jZURhdGEgJiYgeyBkYXRhc2V0LCBwcm9qZWN0SWQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIHVzZSBjdXN0b20gbG9naWMgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBza2lwIGVuY29kaW5nXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgaWYgKGxvZ2dlcikge1xuICAgIGNvbnN0IGlzU2tpcHBpbmcgPSByZXBvcnQuc2tpcHBlZC5sZW5ndGgsIGlzRW5jb2RpbmcgPSByZXBvcnQuZW5jb2RlZC5sZW5ndGg7XG4gICAgaWYgKChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmICgobG9nZ2VyPy5ncm91cENvbGxhcHNlZCB8fCBsb2dnZXIubG9nKT8uKFwiW0BzYW5pdHkvY2xpZW50XTogRW5jb2Rpbmcgc291cmNlIG1hcCBpbnRvIHJlc3VsdFwiKSwgbG9nZ2VyLmxvZz8uKFxuICAgICAgYFtAc2FuaXR5L2NsaWVudF06IFBhdGhzIGVuY29kZWQ6ICR7cmVwb3J0LmVuY29kZWQubGVuZ3RofSwgc2tpcHBlZDogJHtyZXBvcnQuc2tpcHBlZC5sZW5ndGh9YFxuICAgICkpLCByZXBvcnQuZW5jb2RlZC5sZW5ndGggPiAwICYmIChsb2dnZXI/LmxvZz8uKFwiW0BzYW5pdHkvY2xpZW50XTogVGFibGUgb2YgZW5jb2RlZCBwYXRoc1wiKSwgKGxvZ2dlcj8udGFibGUgfHwgbG9nZ2VyLmxvZyk/LihyZXBvcnQuZW5jb2RlZCkpLCByZXBvcnQuc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBza2lwcGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgeyBwYXRoIH0gb2YgcmVwb3J0LnNraXBwZWQpXG4gICAgICAgIHNraXBwZWQuYWRkKHBhdGgucmVwbGFjZShyZUtleVNlZ21lbnQsIFwiMFwiKS5yZXBsYWNlKC9cXFtcXGQrXFxdL2csIFwiW11cIikpO1xuICAgICAgbG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IExpc3Qgb2Ygc2tpcHBlZCBwYXRoc1wiLCBbLi4uc2tpcHBlZC52YWx1ZXMoKV0pO1xuICAgIH1cbiAgICAoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiBsb2dnZXI/Lmdyb3VwRW5kPy4oKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0V2l0aFN0ZWdhO1xufVxuZnVuY3Rpb24gcHJldHR5UGF0aEZvckxvZ2dpbmcocGF0aCkge1xuICByZXR1cm4gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpO1xufVxudmFyIHN0ZWdhRW5jb2RlU291cmNlTWFwJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbn0pO1xuZXhwb3J0IHtcbiAgZW5jb2RlSW50b1Jlc3VsdCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwJDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGVnYUVuY29kZVNvdXJjZU1hcC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n"));

/***/ })

}]);